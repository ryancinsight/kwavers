//! Source Mask Inspection Test
//!
//! Quick test to inspect what masks are generated by different source types.
//! This helps diagnose whether sources are creating spatial patterns vs boundary masks.
//!
//! Author: Ryan Clanton (@ryancinsight)
//! Date: 2025-01-20

use kwavers::domain::grid::Grid;
use kwavers::domain::signal::SineWave;
use kwavers::domain::source::{
    InjectionMode, PlaneWaveConfig, PlaneWaveSource, PointSource, Source, SourceField,
};
use std::sync::Arc;

#[test]
fn test_plane_wave_mask_boundary_only() {
    // Create a small grid
    let nx = 8;
    let ny = 8;
    let nz = 8;
    let dx = 0.1e-3;
    let dy = 0.1e-3;
    let dz = 0.1e-3;

    let grid = Grid::new(nx, ny, nz, dx, dy, dz).expect("Failed to create grid");

    // Create plane wave source with BoundaryOnly mode
    let signal = Arc::new(SineWave::new(1e6, 1e5, 0.0));
    let config = PlaneWaveConfig {
        direction: (0.0, 0.0, 1.0), // +z direction
        wavelength: 1.5e-3,
        phase: 0.0,
        source_type: SourceField::Pressure,
        injection_mode: InjectionMode::BoundaryOnly,
    };

    let source = PlaneWaveSource::new(config, signal);
    let mask = source.create_mask(&grid);

    println!("\n=== Plane Wave Mask (BoundaryOnly mode) ===");
    println!("Grid: {}×{}×{}", nx, ny, nz);
    println!("Direction: +z");

    // Analyze mask
    let mut num_nonzero = 0;
    let mut min_val = f64::INFINITY;
    let mut max_val = f64::NEG_INFINITY;
    let mut z_indices_with_nonzero = std::collections::HashSet::new();

    for i in 0..nx {
        for j in 0..ny {
            for k in 0..nz {
                let val = mask[[i, j, k]];
                if val.abs() > 1e-12 {
                    num_nonzero += 1;
                    min_val = min_val.min(val);
                    max_val = max_val.max(val);
                    z_indices_with_nonzero.insert(k);
                }
            }
        }
    }

    println!("\nMask statistics:");
    println!("  Non-zero points: {}", num_nonzero);
    println!("  Min value: {:.6}", min_val);
    println!("  Max value: {:.6}", max_val);
    println!("  Z indices with sources: {:?}", {
        let mut v: Vec<_> = z_indices_with_nonzero.iter().copied().collect();
        v.sort();
        v
    });

    // Print mask at z=0 plane
    println!("\nMask at z=0 plane:");
    for j in 0..ny {
        for i in 0..nx {
            let val = mask[[i, j, 0]];
            if val.abs() > 1e-12 {
                print!("1 ");
            } else {
                print!(". ");
            }
        }
        println!();
    }

    // Verify expectations for BoundaryOnly mode
    assert_eq!(num_nonzero, nx * ny, "Should have nx×ny boundary points");
    assert_eq!(z_indices_with_nonzero.len(), 1, "Should only be at one z index");
    assert!(z_indices_with_nonzero.contains(&0), "Should be at z=0");
    assert!((min_val - 1.0).abs() < 1e-6, "Mask values should be 1.0");
    assert!((max_val - 1.0).abs() < 1e-6, "Mask values should be 1.0");

    println!("\n✓ BoundaryOnly mask test PASSED");
}

#[test]
fn test_plane_wave_mask_full_grid() {
    // Create a small grid
    let nx = 8;
    let ny = 8;
    let nz = 8;
    let dx = 0.1e-3;
    let dy = 0.1e-3;
    let dz = 0.1e-3;

    let grid = Grid::new(nx, ny, nz, dx, dy, dz).expect("Failed to create grid");

    // Create plane wave source with FullGrid mode
    let signal = Arc::new(SineWave::new(1e6, 1e5, 0.0));
    let config = PlaneWaveConfig {
        direction: (0.0, 0.0, 1.0), // +z direction
        wavelength: 1.5e-3,
        phase: 0.0,
        source_type: SourceField::Pressure,
        injection_mode: InjectionMode::FullGrid,
    };

    let source = PlaneWaveSource::new(config, signal);
    let mask = source.create_mask(&grid);

    println!("\n=== Plane Wave Mask (FullGrid mode) ===");
    println!("Grid: {}×{}×{}", nx, ny, nz);
    println!("Direction: +z");

    // Analyze mask
    let mut num_nonzero = 0;
    let mut min_val = f64::INFINITY;
    let mut max_val = f64::NEG_INFINITY;

    for i in 0..nx {
        for j in 0..ny {
            for k in 0..nz {
                let val = mask[[i, j, k]];
                if val.abs() > 1e-12 {
                    num_nonzero += 1;
                }
                min_val = min_val.min(val);
                max_val = max_val.max(val);
            }
        }
    }

    println!("\nMask statistics:");
    println!("  Non-zero points: {}", num_nonzero);
    println!("  Min value: {:.6}", min_val);
    println!("  Max value: {:.6}", max_val);

    // Print mask values along z axis at center (i=4, j=4)
    println!("\nMask values along z-axis (center line):");
    for k in 0..nz {
        let val = mask[[nx / 2, ny / 2, k]];
        println!("  z={}: {:.6}", k, val);
    }

    // FullGrid mode should create a spatial pattern (cos(k*z)) across the domain
    assert_eq!(num_nonzero, nx * ny * nz, "Should have all grid points active");
    assert!(min_val < 1.0, "Should have varying values (spatial pattern)");
    assert!(
        (max_val - 1.0).abs() < 0.1,
        "Max should be near 1.0 (cos at peak)"
    );

    println!("\n✓ FullGrid mask test PASSED");
}

#[test]
fn test_point_source_mask() {
    // Create a small grid
    let nx = 8;
    let ny = 8;
    let nz = 8;
    let dx = 0.1e-3;
    let dy = 0.1e-3;
    let dz = 0.1e-3;

    let grid = Grid::new(nx, ny, nz, dx, dy, dz).expect("Failed to create grid");

    // Create point source at center
    let signal = Arc::new(SineWave::new(1e6, 1e5, 0.0));
    let position = (
        (nx / 2) as f64 * dx,
        (ny / 2) as f64 * dy,
        (nz / 2) as f64 * dz,
    );
    let source = PointSource::new(position, signal);
    let mask = source.create_mask(&grid);

    println!("\n=== Point Source Mask ===");
    println!("Grid: {}×{}×{}", nx, ny, nz);
    println!("Position: ({:.4}, {:.4}, {:.4}) mm",
        position.0 * 1e3, position.1 * 1e3, position.2 * 1e3);

    // Analyze mask
    let mut num_nonzero = 0;
    let mut source_indices = Vec::new();

    for i in 0..nx {
        for j in 0..ny {
            for k in 0..nz {
                let val = mask[[i, j, k]];
                if val.abs() > 1e-12 {
                    num_nonzero += 1;
                    source_indices.push((i, j, k, val));
                }
            }
        }
    }

    println!("\nMask statistics:");
    println!("  Non-zero points: {}", num_nonzero);
    println!("  Source points:");
    for (i, j, k, val) in &source_indices {
        println!("    ({}, {}, {}): {:.6}", i, j, k, val);
    }

    // Point source should have exactly 1 point
    assert!(
        num_nonzero == 1,
        "Point source should have exactly 1 grid point, found {}",
        num_nonzero
    );

    println!("\n✓ Point source mask test PASSED");
}
