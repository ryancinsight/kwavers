//! Short-Lag Spatial Coherence (SLSC) Beamforming
//!
//! # Overview
//!
//! Short-Lag Spatial Coherence (SLSC) beamforming is an advanced imaging technique
//! that improves image quality by leveraging the spatial coherence of backscattered
//! ultrasound signals. Unlike conventional delay-and-sum beamforming which only uses
//! amplitude information, SLSC exploits the phase coherence between signals received
//! at different array elements.
//!
//! ## Key Advantages
//!
//! - **Improved Clutter Rejection**: Suppresses incoherent noise and reverberation clutter
//! - **Better Contrast**: Enhances tissue boundaries and cyst visualization
//! - **Robust to Phase Aberration**: Less sensitive to sound speed variations
//! - **No Additional Hardware**: Uses same data as conventional beamforming
//!
//! # Mathematical Foundation
//!
//! ## Spatial Coherence
//!
//! The spatial coherence between signals received at elements i and j is defined as:
//!
//! ```text
//! C(d) = |Σ_{k=1}^{N-d} s_k · s_{k+d}^*| / √[Σ|s_k|² · Σ|s_{k+d}|²]
//! ```
//!
//! where:
//! - `d` = element lag (distance between elements)
//! - `s_k` = signal at element k after delay compensation
//! - `N` = total number of elements
//! - `*` = complex conjugate
//!
//! ## Short-Lag Region
//!
//! SLSC only uses short lags (typically d = 1 to M where M << N) because:
//! - Short lags capture local coherence (tissue microstructure)
//! - Long lags are dominated by noise and decorrelation
//! - Short-lag coherence is more robust to phase aberrations
//!
//! ## SLSC Image Formation
//!
//! The SLSC image value at each pixel is computed as:
//!
//! ```text
//! I_SLSC = Σ_{d=1}^{M} w(d) · C(d)
//! ```
//!
//! where:
//! - `M` = maximum lag (typically 10-20% of array aperture)
//! - `w(d)` = optional weighting function (e.g., triangular, Hamming)
//! - `C(d)` = spatial coherence at lag d
//!
//! # Algorithm Steps
//!
//! 1. **Delay Compensation**: Apply geometric delays to align signals
//! 2. **Lag Correlation**: Compute correlation for each short lag
//! 3. **Normalization**: Normalize by signal energy
//! 4. **Coherence Summation**: Sum weighted coherence values
//!
//! # Implementation Notes
//!
//! This implementation follows the SSOT (Single Source of Truth) principle:
//! - Uses existing delay computation from `time_domain` module
//! - Leverages covariance estimation from `covariance` module
//! - No redundant implementations or wrapper layers
//!
//! # References
//!
//! - Lediju, M. A., et al. (2011). "Short-lag spatial coherence of backscattered echoes:
//!   Imaging characteristics." *IEEE Trans. Ultrason., Ferroelect., Freq. Control*, 58(7).
//!   DOI: 10.1109/TUFFC.2011.1957
//!
//! - Jakovljevic, M., et al. (2013). "In vivo application of short-lag spatial coherence
//!   imaging in human liver." *Ultrasonic Imaging*, 35(3).
//!   DOI: 10.1177/0161734613489682

use crate::core::error::{KwaversError, KwaversResult};
use ndarray::{Array1, Array2, Array3, ArrayView1, ArrayView2, ArrayView3, Axis};
use num_complex::Complex64;
use rayon::prelude::*;

/// Configuration for SLSC beamforming
#[derive(Debug, Clone, Copy)]
pub struct SlscConfig {
    /// Maximum lag to use (M). Typically 10-20% of array elements.
    pub max_lag: usize,
    /// Weighting function for different lags
    pub weighting: LagWeighting,
    /// Whether to use normalized coherence
    pub normalize: bool,
}

impl Default for SlscConfig {
    fn default() -> Self {
        Self {
            max_lag: 10,
            weighting: LagWeighting::Uniform,
            normalize: true,
        }
    }
}

impl SlscConfig {
    /// Create config with specific max lag
    #[must_use]
    pub fn with_max_lag(max_lag: usize) -> Self {
        Self {
            max_lag,
            ..Default::default()
        }
    }

    /// Create config with triangular weighting
    #[must_use]
    pub fn with_triangular_weighting(max_lag: usize) -> Self {
        Self {
            max_lag,
            weighting: LagWeighting::Triangular,
            ..Default::default()
        }
    }
}

/// Weighting functions for lag coherence
#[derive(Debug, Clone, Copy)]
pub enum LagWeighting {
    /// Equal weight for all lags
    Uniform,
    /// Linearly decreasing weight with lag
    Triangular,
    /// Hamming window weighting
    Hamming,
}

impl LagWeighting {
    /// Compute weight for a specific lag
    fn weight(&self, lag: usize, max_lag: usize) -> f64 {
        match self {
            LagWeighting::Uniform => 1.0,
            LagWeighting::Triangular => {
                let ratio = lag as f64 / max_lag as f64;
                1.0 - ratio
            }
            LagWeighting::Hamming => {
                let n = lag as f64;
                let m = max_lag as f64;
                0.54 - 0.46 * (2.0 * std::f64::consts::PI * n / m).cos()
            }
        }
    }
}

/// Short-Lag Spatial Coherence beamformer
pub struct SlscBeamformer {
    config: SlscConfig,
}

impl SlscBeamformer {
    /// Create new SLSC beamformer with default configuration
    #[must_use]
    pub fn new() -> Self {
        Self {
            config: SlscConfig::default(),
        }
    }

    /// Create beamformer with custom configuration
    #[must_use]
    pub fn with_config(config: SlscConfig) -> Self {
        Self { config }
    }

    /// Compute SLSC image from pre-delayed channel data
    ///
    /// # Arguments
    ///
    /// * `channel_data` - Delayed channel data with shape (n_elements, n_samples)
    ///
    /// # Returns
    ///
    /// SLSC image values with shape (n_samples,)
    ///
    /// # Errors
    ///
    /// Returns error if input dimensions are invalid
    pub fn process(&self, channel_data: &Array2<Complex64>) -> KwaversResult<Array1<f64>> {
        let n_elements = channel_data.nrows();
        let n_samples = channel_data.ncols();
        let max_lag = self.config.max_lag.min(n_elements - 1);

        if n_elements < 2 {
            return Err(KwaversError::InvalidInput(
                "SLSC requires at least 2 elements".to_string(),
            ));
        }

        // Process each time sample
        let mut slsc_values = Array1::zeros(n_samples);

        for sample_idx in 0..n_samples {
            let sample_data = channel_data.column(sample_idx);
            let coherence_sum = self.compute_coherence_sum(&sample_data, max_lag);
            slsc_values[sample_idx] = coherence_sum;
        }

        Ok(slsc_values)
    }

    /// Compute SLSC image for a 2D grid (B-mode imaging)
    ///
    /// # Arguments
    ///
    /// * `channel_data` - Delayed channel data with shape (n_elements, n_pixels)
    /// * `grid_shape` - Shape of output image (height, width)
    ///
    /// # Returns
    ///
    /// SLSC image with shape (height, width)
    pub fn process_grid(
        &self,
        channel_data: &Array2<Complex64>,
        grid_shape: (usize, usize),
    ) -> KwaversResult<Array2<f64>> {
        let n_pixels = channel_data.ncols();
        let (height, width) = grid_shape;

        if n_pixels != height * width {
            return Err(KwaversError::InvalidInput(format!(
                "SLSC grid: channel data has {} pixels but grid is {}x{}={}",
                n_pixels,
                height,
                width,
                height * width
            )));
        }

        let slsc_1d = self.process(channel_data)?;
        let slsc_2d = slsc_1d.into_shape((height, width)).map_err(|e| {
            KwaversError::InvalidInput(format!("SLSC reshape error: {}", e))
        })?;

        Ok(slsc_2d)
    }

    /// Compute spatial coherence sum for a single sample across all short lags
    fn compute_coherence_sum(
        &self,
        sample_data: &ArrayView1<Complex64>,
        max_lag: usize,
    ) -> f64 {
        let n = sample_data.len();
        let mut total_coherence = 0.0;
        let mut total_weight = 0.0;

        for lag in 1..=max_lag {
            if lag >= n {
                break;
            }

            let coherence = self.compute_lag_coherence(sample_data, lag);
            let weight = self.config.weighting.weight(lag, max_lag);

            total_coherence += weight * coherence;
            total_weight += weight;
        }

        if total_weight > 0.0 {
            total_coherence / total_weight
        } else {
            0.0
        }
    }

    /// Compute normalized spatial coherence for a specific lag
    ///
    /// Returns value in [0, 1] where 1 indicates perfect coherence
    fn compute_lag_coherence(&self, data: &ArrayView1<Complex64>, lag: usize) -> f64 {
        let n = data.len();
        let num_pairs = n - lag;

        if num_pairs == 0 {
            return 0.0;
        }

        // Compute correlation sum: Σ s_i · s_{i+lag}*
        let mut correlation = Complex64::new(0.0, 0.0);
        let mut energy_i = 0.0f64;
        let mut energy_j = 0.0f64;

        for i in 0..num_pairs {
            let j = i + lag;
            let si = data[i];
            let sj = data[j];

            correlation += si * sj.conj();
            energy_i += si.norm_sqr();
            energy_j += sj.norm_sqr();
        }

        if !self.config.normalize {
            // Return unnormalized correlation magnitude
            return correlation.norm();
        }

        // Normalized coherence: |correlation| / √(energy_i · energy_j)
        let energy_product = energy_i * energy_j;
        if energy_product > 0.0 {
            correlation.norm() / energy_product.sqrt()
        } else {
            0.0
        }
    }

    /// Get current configuration
    #[must_use]
    pub fn config(&self) -> &SlscConfig {
        &self.config
    }
}

impl Default for SlscBeamformer {
    fn default() -> Self {
        Self::new()
    }
}

/// Compute SLSC image with parallel processing for large datasets
pub fn slsc_parallel(
    channel_data: &Array3<Complex64>,
    config: &SlscConfig,
) -> KwaversResult<Array2<f64>> {
    let n_frames = channel_data.shape()[0];
    let n_elements = channel_data.shape()[1];
    let n_samples = channel_data.shape()[2];

    if n_elements < 2 {
        return Err(KwaversError::InvalidInput(
            "SLSC parallel requires at least 2 elements".to_string(),
        ));
    }

    let max_lag = config.max_lag.min(n_elements - 1);

    // Process frames in parallel
    let results: Vec<_> = (0..n_frames)
        .into_par_iter()
        .map(|frame_idx| {
            let frame_data = channel_data.slice(ndarray::s![frame_idx, .., ..]);
            let mut frame_result = Array1::zeros(n_samples);

            for sample_idx in 0..n_samples {
                let sample_data = frame_data.column(sample_idx);

                let mut total_coherence = 0.0;
                let mut total_weight = 0.0;

                for lag in 1..=max_lag {
                    if lag >= n_elements {
                        break;
                    }

                    // Compute coherence for this lag
                    let num_pairs = n_elements - lag;
                    let mut correlation = Complex64::new(0.0, 0.0);
                    let mut energy_i = 0.0f64;
                    let mut energy_j = 0.0f64;

                    for i in 0..num_pairs {
                        let j = i + lag;
                        let si = sample_data[i];
                        let sj = sample_data[j];

                        correlation += si * sj.conj();
                        energy_i += si.norm_sqr();
                        energy_j += sj.norm_sqr();
                    }

                    let coherence = if config.normalize && energy_i * energy_j > 0.0 {
                        correlation.norm() / (energy_i * energy_j).sqrt()
                    } else {
                        correlation.norm()
                    };

                    let weight = config.weighting.weight(lag, max_lag);
                    total_coherence += weight * coherence;
                    total_weight += weight;
                }

                frame_result[sample_idx] = if total_weight > 0.0 {
                    total_coherence / total_weight
                } else {
                    0.0
                };
            }

            frame_result
        })
        .collect();

    // Combine results
    let mut output = Array2::zeros((n_frames, n_samples));
    for (frame_idx, frame_result) in results.iter().enumerate() {
        output.row_mut(frame_idx).assign(frame_result);
    }

    Ok(output)
}

#[cfg(test)]
mod tests {
    use super::*;
    use ndarray::Array2;

    #[test]
    fn test_slsc_default_config() {
        let slsc = SlscBeamformer::new();
        assert_eq!(slsc.config().max_lag, 10);
        assert!(slsc.config().normalize);
    }

    #[test]
    fn test_slsc_with_config() {
        let config = SlscConfig::with_max_lag(20);
        let slsc = SlscBeamformer::with_config(config);
        assert_eq!(slsc.config().max_lag, 20);
    }

    #[test]
    fn test_slsc_process_simple() {
        // Create simple test data: 4 elements, 10 samples
        let n_elements = 4;
        let n_samples = 10;
        let data = Array2::from_elem((n_elements, n_samples), Complex64::new(1.0, 0.0));

        let slsc = SlscBeamformer::new();
        let result = slsc.process(&data).expect("SLSC processing should succeed");

        assert_eq!(result.len(), n_samples);
        // Perfectly coherent signals should give high coherence values
        for &val in result.iter() {
            assert!(val >= 0.0 && val <= 1.0, "Coherence should be in [0, 1]");
        }
    }

    #[test]
    fn test_slsc_rejects_single_element() {
        let data = Array2::from_elem((1, 10), Complex64::new(1.0, 0.0));
        let slsc = SlscBeamformer::new();
        let result = slsc.process(&data);
        assert!(result.is_err());
    }

    #[test]
    fn test_lag_weighting_uniform() {
        let w = LagWeighting::Uniform;
        assert_eq!(w.weight(1, 10), 1.0);
        assert_eq!(w.weight(5, 10), 1.0);
    }

    #[test]
    fn test_lag_weighting_triangular() {
        let w = LagWeighting::Triangular;
        assert_eq!(w.weight(0, 10), 1.0);
        assert_eq!(w.weight(5, 10), 0.5);
        assert_eq!(w.weight(10, 10), 0.0);
    }

    #[test]
    fn test_slsc_grid_processing() {
        let n_elements = 8;
        let height = 10;
        let width = 20;
        let n_pixels = height * width;

        let data = Array2::from_elem((n_elements, n_pixels), Complex64::new(1.0, 0.0));
        let slsc = SlscBeamformer::new();
        let result = slsc
            .process_grid(&data, (height, width))
            .expect("Grid processing should succeed");

        assert_eq!(result.shape(), &[height, width]);
    }
}
