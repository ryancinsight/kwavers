//! Conservation law validation for physical simulations
//! 
//! Ensures energy, mass, and momentum are conserved according to fundamental physics

use ndarray::{Array3, Zip};
use crate::grid::Grid;
use crate::error::KwaversResult;

/// Conservation validation results
#[derive(Debug, Clone)]
pub struct ConservationMetrics {
    pub energy_error: f64,
    pub mass_error: f64,
    pub momentum_error: (f64, f64, f64),
    pub is_conserved: bool,
}

/// Validate energy conservation: ∫E(t)dV = ∫E(0)dV + work done
pub fn validate_energy_conservation(
    pressure: &Array3<f64>,
    velocity_x: &Array3<f64>,
    velocity_y: &Array3<f64>,
    velocity_z: &Array3<f64>,
    density: &Array3<f64>,
    initial_energy: f64,
    grid: &Grid,
) -> f64 {
    let mut total_energy = 0.0;
    let dv = grid.dx * grid.dy * grid.dz;
    
    // E = (1/2)ρv² + p²/(2ρc²)
    // Assuming c = 1500 m/s for simplicity
    let c_squared = 1500.0 * 1500.0;
    
    Zip::from(pressure)
        .and(velocity_x)
        .and(velocity_y)
        .and(velocity_z)
        .and(density)
        .for_each(|&p, &vx, &vy, &vz, &rho| {
            let kinetic = 0.5 * rho * (vx * vx + vy * vy + vz * vz);
            let potential = p * p / (2.0 * rho * c_squared);
            total_energy += (kinetic + potential) * dv;
        });
    
    (total_energy - initial_energy).abs() / initial_energy.max(1e-10)
}

/// Validate mass conservation: ∂ρ/∂t + ∇·(ρv) = 0
pub fn validate_mass_conservation(
    density: &Array3<f64>,
    density_previous: &Array3<f64>,
    velocity_x: &Array3<f64>,
    velocity_y: &Array3<f64>,
    velocity_z: &Array3<f64>,
    dt: f64,
    grid: &Grid,
) -> f64 {
    let mut max_error: f64 = 0.0;
    let dx_inv = 1.0 / grid.dx;
    let dy_inv = 1.0 / grid.dy;
    let dz_inv = 1.0 / grid.dz;
    let dt_inv = 1.0 / dt;
    
    // Check interior points only
    for i in 1..grid.nx-1 {
        for j in 1..grid.ny-1 {
            for k in 1..grid.nz-1 {
                // Time derivative
                let drho_dt = (density[[i,j,k]] - density_previous[[i,j,k]]) * dt_inv;
                
                // Divergence of mass flux
                let div_flux = 
                    (density[[i+1,j,k]] * velocity_x[[i+1,j,k]] - 
                     density[[i-1,j,k]] * velocity_x[[i-1,j,k]]) * 0.5 * dx_inv +
                    (density[[i,j+1,k]] * velocity_y[[i,j+1,k]] - 
                     density[[i,j-1,k]] * velocity_y[[i,j-1,k]]) * 0.5 * dy_inv +
                    (density[[i,j,k+1]] * velocity_z[[i,j,k+1]] - 
                     density[[i,j,k-1]] * velocity_z[[i,j,k-1]]) * 0.5 * dz_inv;
                
                // Conservation error
                let error = (drho_dt + div_flux).abs();
                max_error = max_error.max(error);
            }
        }
    }
    
    max_error
}

/// Validate momentum conservation: ρ∂v/∂t + ∇p = 0
pub fn validate_momentum_conservation(
    velocity_x: &Array3<f64>,
    velocity_y: &Array3<f64>,
    velocity_z: &Array3<f64>,
    velocity_x_previous: &Array3<f64>,
    velocity_y_previous: &Array3<f64>,
    velocity_z_previous: &Array3<f64>,
    pressure: &Array3<f64>,
    density: &Array3<f64>,
    dt: f64,
    grid: &Grid,
) -> (f64, f64, f64) {
    let mut max_error_x: f64 = 0.0;
    let mut max_error_y: f64 = 0.0;
    let mut max_error_z: f64 = 0.0;
    
    let dx_inv = 1.0 / grid.dx;
    let dy_inv = 1.0 / grid.dy;
    let dz_inv = 1.0 / grid.dz;
    let dt_inv = 1.0 / dt;
    
    // Check interior points
    for i in 1..grid.nx-1 {
        for j in 1..grid.ny-1 {
            for k in 1..grid.nz-1 {
                let rho = density[[i,j,k]];
                
                // X-momentum
                let dvx_dt = (velocity_x[[i,j,k]] - velocity_x_previous[[i,j,k]]) * dt_inv;
                let dpx_dx = (pressure[[i+1,j,k]] - pressure[[i-1,j,k]]) * 0.5 * dx_inv;
                max_error_x = max_error_x.max((rho * dvx_dt + dpx_dx).abs());
                
                // Y-momentum
                let dvy_dt = (velocity_y[[i,j,k]] - velocity_y_previous[[i,j,k]]) * dt_inv;
                let dpy_dy = (pressure[[i,j+1,k]] - pressure[[i,j-1,k]]) * 0.5 * dy_inv;
                max_error_y = max_error_y.max((rho * dvy_dt + dpy_dy).abs());
                
                // Z-momentum
                let dvz_dt = (velocity_z[[i,j,k]] - velocity_z_previous[[i,j,k]]) * dt_inv;
                let dpz_dz = (pressure[[i,j,k+1]] - pressure[[i,j,k-1]]) * 0.5 * dz_inv;
                max_error_z = max_error_z.max((rho * dvz_dt + dpz_dz).abs());
            }
        }
    }
    
    (max_error_x, max_error_y, max_error_z)
}

/// Comprehensive conservation validation
pub fn validate_conservation(
    pressure: &Array3<f64>,
    velocity_x: &Array3<f64>,
    velocity_y: &Array3<f64>,
    velocity_z: &Array3<f64>,
    density: &Array3<f64>,
    pressure_previous: Option<&Array3<f64>>,
    velocity_x_previous: Option<&Array3<f64>>,
    velocity_y_previous: Option<&Array3<f64>>,
    velocity_z_previous: Option<&Array3<f64>>,
    density_previous: Option<&Array3<f64>>,
    initial_energy: f64,
    dt: f64,
    grid: &Grid,
    tolerance: f64,
) -> ConservationMetrics {
    // Energy conservation
    let energy_error = validate_energy_conservation(
        pressure, velocity_x, velocity_y, velocity_z, density, initial_energy, grid
    );
    
    // Mass conservation (if previous state available)
    let mass_error = if let Some(density_prev) = density_previous {
        validate_mass_conservation(
            density, density_prev, velocity_x, velocity_y, velocity_z, dt, grid
        )
    } else {
        0.0
    };
    
    // Momentum conservation (if previous state available)
    let momentum_error = if let (Some(vx_prev), Some(vy_prev), Some(vz_prev)) = 
        (velocity_x_previous, velocity_y_previous, velocity_z_previous) {
        validate_momentum_conservation(
            velocity_x, velocity_y, velocity_z,
            vx_prev, vy_prev, vz_prev,
            pressure, density, dt, grid
        )
    } else {
        (0.0, 0.0, 0.0)
    };
    
    let is_conserved = energy_error < tolerance && 
                       mass_error < tolerance &&
                       momentum_error.0 < tolerance &&
                       momentum_error.1 < tolerance &&
                       momentum_error.2 < tolerance;
    
    ConservationMetrics {
        energy_error,
        mass_error,
        momentum_error,
        is_conserved,
    }
}