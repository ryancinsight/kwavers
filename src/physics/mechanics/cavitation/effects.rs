// src/physics/mechanics/cavitation/effects.rs
use super::model::{CavitationModel, MIN_RADIUS_MODEL_DEFAULT};
use crate::grid::Grid;
use crate::medium::Medium;
use crate::physics::scattering::acoustic::{
    compute_bubble_interactions, compute_mie_scattering, compute_rayleigh_scattering,
};
use ndarray::Array3;
use std::f64::consts::PI;

/// Stefan-Boltzmann constant (W m^-2 K^-4).
/// Used in calculating black-body radiation for sonoluminescence.
pub(crate) const STEFAN_BOLTZMANN: f64 = 5.670374419e-8;

impl CavitationModel {
    /// Calculates the acoustic effects of bubble oscillations, including scattering and pressure changes due to volume pulsation.
    ///
    /// This method updates the acoustic pressure field (`p_update`) based on several phenomena:
    /// 1.  **Scattering**: Computes Rayleigh, Mie, and bubble-interaction scattering contributions
    ///     and stores them in `self.rayleigh_scatter`, `self.mie_scatter`, and `self.interaction_scatter` respectively.
    ///     The total scattering effect is then incorporated into the pressure update.
    /// 2.  **Volume Pulsation**: Calculates the change in pressure due to the rate of change of bubble volume (`d_volume_dt`).
    ///
    /// It also triggers the calculation of light emission from the bubbles.
    ///
    /// # Arguments
    ///
    /// * `p_update` - A mutable reference to the 3D array representing the acoustic pressure field to be updated.
    /// * `p` - A reference to the current 3D acoustic pressure field.
    /// * `grid` - A reference to the `Grid` structure.
    /// * `medium` - A trait object implementing `Medium`.
    /// * `_has_extreme_pressure` - A boolean flag indicating if extreme pressure conditions were detected (currently unused in this method but kept for signature consistency from original design).
    ///
    /// # Returns
    ///
    /// An `Array3<f64>` representing the light source term (power per unit volume, W/m^3) generated by sonoluminescence.
    ///
    /// # Modifies
    ///
    /// * `self.rayleigh_scatter`, `self.mie_scatter`, `self.interaction_scatter`: Updated with new scattering values.
    /// * `p_update`: The input pressure array is modified to include effects of bubble activity.
    pub(crate) fn calculate_acoustic_effects(
        &mut self,
        p_update: &mut Array3<f64>,
        p: &Array3<f64>,
        grid: &Grid,
        medium: &dyn Medium,
        _has_extreme_pressure: bool, 
    ) -> Array3<f64> {
        self.rayleigh_scatter.fill(0.0);
        self.mie_scatter.fill(0.0);
        self.interaction_scatter.fill(0.0);
        
        let scattering_frequency = 1.0e6; 
        compute_rayleigh_scattering(&mut self.rayleigh_scatter, &self.radius, p, grid, medium, scattering_frequency);
        compute_mie_scattering(&mut self.mie_scatter, &self.radius, p, grid, medium, scattering_frequency);
        compute_bubble_interactions(&mut self.interaction_scatter, &self.radius, &self.velocity, p, grid, medium, scattering_frequency);
        
        for i in 0..grid.nx {
            for j in 0..grid.ny {
                for k in 0..grid.nz {
                    let r = self.radius[[i, j, k]];
                    let v = self.velocity[[i, j, k]];
                    let total_scatter = self.rayleigh_scatter[[i, j, k]] + 
                                        self.mie_scatter[[i, j, k]] + 
                                        self.interaction_scatter[[i, j, k]];
                    
                    let dx = grid.dx; 
                    let dy = grid.dy;
                    let dz = grid.dz;
                    let cell_volume = (dx * dy * dz).max(1e-18); 
                    
                    let d_volume_dt = 4.0 * PI * r.powi(2) * v;
                    
                    p_update[[i, j, k]] -= d_volume_dt / cell_volume + total_scatter;
                    
                    if !p_update[[i, j, k]].is_finite() {
                        p_update[[i, j, k]] = 0.0;
                    }
                }
            }
        }
        
        let mut light_source = Array3::zeros(p.dim());
        self.calculate_light_emission(&mut light_source, grid, medium, 1.0e-3);
        
        light_source
    }
    
    /// Calculates the light emitted by collapsing bubbles (sonoluminescence) and updates bubble temperatures.
    ///
    /// This method models two primary thermal processes for bubbles:
    /// 1.  **Adiabatic Heating on Collapse**: If a bubble is detected to have collapsed (radial velocity
    ///     changes from negative to non-negative), its internal temperature is increased based on
    ///     adiabatic compression. The maximum temperature is capped (e.g., at 5000K).
    ///     Light emission is then calculated as black-body radiation using the Stefan-Boltzmann law
    ///     based on this peak temperature and the bubble's surface area.
    /// 2.  **Thermal Cooling**: If the bubble is not collapsing and emitting light, it is assumed to
    ///     cool down due to thermal conduction with the surrounding medium.
    ///
    /// # Arguments
    ///
    /// * `light_source` - A mutable reference to a 3D array where the calculated light emission
    ///   (power per unit volume, W/m^3) will be stored.
    /// * `grid` - A reference to the `Grid` structure.
    /// * `medium` - A trait object implementing `Medium`.
    /// * `dt` - A time step, specifically used here for the thermal cooling calculation. This might
    ///   differ from the main simulation `dt` and represent a characteristic time for thermal relaxation.
    ///
    /// # Modifies
    ///
    /// * `self.temperature`: The internal temperature of bubbles is updated based on heating or cooling.
    /// * `light_source`: Updated with the calculated power density of emitted light.
    pub(crate) fn calculate_light_emission(
        &mut self,
        light_source: &mut Array3<f64>,
        grid: &Grid,
        medium: &dyn Medium,
        dt: f64, 
    ) {
        for i in 0..grid.nx {
            for j in 0..grid.ny {
                for k in 0..grid.nz {
                    let r = self.radius[[i, j, k]];
                    let v = self.velocity[[i, j, k]];
                    let v_prev = self.prev_velocity[[i, j, k]];
                    let t_bubble = &mut self.temperature[[i, j, k]]; 
                    let medium_temp = medium.temperature()[[i, j, k]]; 
                    
                    if v_prev < 0.0 && v >= 0.0 { // Bubble collapse condition
                        let r0 = 10e-6; 
                        let r_clamped = r.max(MIN_RADIUS_MODEL_DEFAULT); 
                        let gamma = medium.polytropic_index(i as f64 * grid.dx, j as f64 * grid.dy, k as f64 * grid.dz, grid);
                        let t_max = (*t_bubble * (r0 / r_clamped).powf(3.0 * (gamma - 1.0))).min(5000.0); 
                        *t_bubble = t_max;
                        
                        let cell_volume = (grid.dx * grid.dy * grid.dz).max(1e-18);
                        let power = 4.0 * PI * r_clamped.powi(2) * STEFAN_BOLTZMANN * t_max.powi(4);
                        light_source[[i, j, k]] = power / cell_volume;
                    } else { // Bubble expanding or not at peak collapse
                        light_source[[i, j, k]] = 0.0;
                        
                        let kappa = medium.thermal_conductivity(i as f64 * grid.dx, j as f64 * grid.dy, k as f64 * grid.dz, grid);
                        let rho_medium = medium.density(i as f64 * grid.dx, j as f64 * grid.dy, k as f64 * grid.dz, grid);
                        let r_clamped = r.max(MIN_RADIUS_MODEL_DEFAULT);
                        let temp_diff = *t_bubble - medium_temp;
                        
                        if r_clamped > 1e-12 && rho_medium > 1e-3 { 
                           *t_bubble -= kappa * temp_diff * dt / (r_clamped * rho_medium); 
                        }
                        *t_bubble = t_bubble.max(medium_temp); 
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::grid::Grid;
    use crate::medium::Medium;
    use crate::medium::tissue_specific; // For tissue_type Option
    use ndarray::{Array3, ShapeBuilder}; // Added ShapeBuilder for .f()

    fn create_test_grid(nx: usize, ny: usize, nz: usize) -> Grid {
        Grid::new(nx, ny, nz, 0.01, 0.01, 0.01)
    }

    #[derive(Debug)]
    struct MockMedium {
        density_val: f64,
        polytropic_index_val: f64,
        thermal_conductivity_val: f64,
        medium_temperature_val: Array3<f64>,
        // Dummy fields for other trait methods
        dummy_bubble_radius: Array3<f64>, 
        dummy_bubble_velocity: Array3<f64>, 
    }

    impl Default for MockMedium {
        fn default() -> Self {
            let default_dim = (1,1,1);
            Self {
                density_val: 1000.0,
                polytropic_index_val: 1.4,
                thermal_conductivity_val: 0.6,
                medium_temperature_val: Array3::from_elem(default_dim.f(), 293.15),
                dummy_bubble_radius: Array3::zeros(default_dim.f()),
                dummy_bubble_velocity: Array3::zeros(default_dim.f()),
            }
        }
    }
    
    impl Medium for MockMedium {
        fn density(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { self.density_val }
        fn sound_speed(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { 1500.0 }
        fn viscosity(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { 0.001 }
        fn surface_tension(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { 0.072 }
        fn ambient_pressure(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { 101325.0 }
        fn vapor_pressure(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { 2330.0 }
        fn polytropic_index(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { self.polytropic_index_val }
        fn thermal_conductivity(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { self.thermal_conductivity_val }
        fn gas_diffusion_coefficient(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { 2e-9 }
        fn temperature(&self) -> &Array3<f64> { &self.medium_temperature_val }
        
        fn is_homogeneous(&self) -> bool { true }
        fn specific_heat(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { 4186.0 }
        fn absorption_coefficient(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid, _frequency: f64) -> f64 { 0.0 }
        fn thermal_expansion(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { 2.1e-4 }
        fn thermal_diffusivity(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { 1.43e-7 }
        fn nonlinearity_coefficient(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { 5.0 }
        fn absorption_coefficient_light(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { 0.1 }
        fn reduced_scattering_coefficient_light(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> f64 { 1.0 }
        fn reference_frequency(&self) -> f64 { 1e6 }
        fn tissue_type(&self, _x: f64, _y: f64, _z: f64, _grid: &Grid) -> Option<tissue_specific::TissueType> { None }
        fn update_temperature(&mut self, _temperature: &Array3<f64>) {}
        fn bubble_radius(&self) -> &Array3<f64> { &self.dummy_bubble_radius }
        fn bubble_velocity(&self) -> &Array3<f64> { &self.dummy_bubble_velocity }
        fn update_bubble_state(&mut self, _radius: &Array3<f64>, _velocity: &Array3<f64>) {}
        fn density_array(&self) -> Array3<f64> { Array3::from_elem(self.medium_temperature_val.dim(), self.density_val) }
        fn sound_speed_array(&self) -> Array3<f64> { Array3::from_elem(self.medium_temperature_val.dim(), 1500.0) }
    }

    #[test]
    fn test_calculate_acoustic_effects_pressure_update() {
        let grid_dims = (1,1,1);
        let test_grid = create_test_grid(grid_dims.0, grid_dims.1, grid_dims.2);
        let mut model = CavitationModel::new(&test_grid, 5e-6);
        
        let test_radius = 10e-6;
        let test_velocity = 10.0;
        model.radius[[0,0,0]] = test_radius;
        model.velocity[[0,0,0]] = test_velocity;

        // Manually zero out scattering effects for this test
        model.rayleigh_scatter.fill(0.0);
        model.mie_scatter.fill(0.0);
        model.interaction_scatter.fill(0.0);

        let mut p_update = Array3::zeros(grid_dims.f());
        let p_acoustic = Array3::zeros(grid_dims.f()); // No external acoustic pressure for simplicity

        let mock_medium = MockMedium::default();
        
        model.calculate_acoustic_effects(&mut p_update, &p_acoustic, &test_grid, &mock_medium, false);

        let cell_volume = test_grid.dx * test_grid.dy * test_grid.dz;
        let d_volume_dt = 4.0 * PI * test_radius.powi(2) * test_velocity;
        let expected_p_change = -d_volume_dt / cell_volume;

        assert!((p_update[[0,0,0]] - expected_p_change).abs() < 1e-9, "p_update not correct for d_volume_dt effect");
    }

    #[test]
    fn test_calculate_light_emission_collapse() {
        let grid_dims = (1,1,1);
        let test_grid = create_test_grid(grid_dims.0, grid_dims.1, grid_dims.2);
        let mut model = CavitationModel::new(&test_grid, 2e-6); // Small initial radius
        
        let initial_temp = 293.15;
        model.temperature.fill(initial_temp);
        model.radius[[0,0,0]] = MIN_RADIUS_MODEL_DEFAULT * 1.1; // Slightly above min
        model.prev_velocity[[0,0,0]] = -100.0; // Collapsing
        model.velocity[[0,0,0]] = 0.5;        // Rebounded

        let mock_medium = MockMedium {
            medium_temperature_val: Array3::from_elem(grid_dims.f(), initial_temp),
            ..MockMedium::default()
        };
        let mut light_source = Array3::zeros(grid_dims.f());
        let dt_light = 1e-7; // Small dt for cooling model

        model.calculate_light_emission(&mut light_source, &test_grid, &mock_medium, dt_light);

        assert!(light_source[[0,0,0]] > 0.0, "Light source should be non-zero on collapse");
        assert!(model.temperature[[0,0,0]] > initial_temp, "Bubble temperature should increase on collapse");
    }

    #[test]
    fn test_calculate_light_emission_no_collapse() {
        let grid_dims = (1,1,1);
        let test_grid = create_test_grid(grid_dims.0, grid_dims.1, grid_dims.2);
        let mut model = CavitationModel::new(&test_grid, 5e-6);
        
        let initial_temp = 350.0; // Start slightly warmer than ambient for cooling check
        model.temperature.fill(initial_temp);
        model.radius[[0,0,0]] = 5e-6;
        model.prev_velocity[[0,0,0]] = 1.0;  // Not collapsing
        model.velocity[[0,0,0]] = 0.5;       // Still expanding or less rapid collapse

        let mock_medium_temp = 293.15;
        let mock_medium = MockMedium {
            medium_temperature_val: Array3::from_elem(grid_dims.f(), mock_medium_temp),
            ..MockMedium::default()
        };
        let mut light_source = Array3::zeros(grid_dims.f());
        let dt_light = 1e-3; // dt for cooling

        model.calculate_light_emission(&mut light_source, &test_grid, &mock_medium, dt_light);

        assert_eq!(light_source[[0,0,0]], 0.0, "Light source should be zero if not collapsing");
        assert!(model.temperature[[0,0,0]] < initial_temp, "Bubble temperature should decrease due to cooling");
        assert!(model.temperature[[0,0,0]] >= mock_medium_temp, "Bubble temperature should not go below medium temp");
    }
}
