//! Stone Fracture Mechanics for Lithotripsy
//!
//! Models the fracture and fragmentation of urinary calculi under ultrasonic loading.
//! Implements Griffith fracture criterion, dynamic crack propagation, and material
//! failure mechanics specific to kidney and gall stones.
//!
//! ## Key Theories
//!
//! 1. **Griffith Fracture Criterion**: Energy balance for crack initiation
//!    W_critical = 2γ / σ_max (where γ is surface energy, σ_max is max stress)
//!
//! 2. **Dynamic Fracture Propagation**: Crack velocity and branching
//!    da/dt = v_crack(σ, material_properties)
//!
//! 3. **Stone Material Properties**: Heterogeneous composition affects fracture
//!
//! ## References
//!
//! - Coleman et al. (1987): "Acoustic cavitation generated by an extracorporeal shockwave lithotripter"
//! - Cleveland et al. (2000): "The physics of shock wave lithotripsy"
//! - Pishchalnikov et al. (2003): "Cavitation bubble cluster activity in shock wave lithotripsy"

use crate::error::ValidationError;
use crate::validation::ValidationResult;
use ndarray::Array3;
use serde::{Deserialize, Serialize};
use std::f64::consts::PI;

/// Stone material properties
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StoneMaterial {
    /// Young's modulus [Pa]
    pub youngs_modulus: f64,
    /// Poisson's ratio
    pub poissons_ratio: f64,
    /// Density [kg/m³]
    pub density: f64,
    /// Fracture toughness [Pa·√m]
    pub fracture_toughness: f64,
    /// Surface energy [J/m²]
    pub surface_energy: f64,
    /// Compressive strength [Pa]
    pub compressive_strength: f64,
    /// Tensile strength [Pa]
    pub tensile_strength: f64,
    /// Hardness [Pa]
    pub hardness: f64,
    /// Acoustic impedance [kg/(m²·s)]
    pub acoustic_impedance: f64,
    /// Attenuation coefficient [Np/m]
    pub attenuation_coefficient: f64,
}

impl Default for StoneMaterial {
    fn default() -> Self {
        // Calcium oxalate monohydrate (COM) - most common kidney stone
        Self {
            youngs_modulus: 20e9, // 20 GPa
            poissons_ratio: 0.25,
            density: 2100.0,               // kg/m³
            fracture_toughness: 0.5e6,     // Pa·√m (lower than ceramics)
            surface_energy: 0.5,           // J/m²
            compressive_strength: 50e6,    // 50 MPa
            tensile_strength: 5e6,         // 5 MPa (much lower than compression)
            hardness: 3e9,                 // Vickers hardness
            acoustic_impedance: 4.4e6,     // Z = ρ·c
            attenuation_coefficient: 50.0, // Np/m at 1 MHz
        }
    }
}

impl StoneMaterial {
    /// Calcium oxalate monohydrate (COM) - most common stone type
    #[must_use]
    pub fn calcium_oxalate_monohydrate() -> Self {
        Self::default()
    }

    /// Calcium oxalate dihydrate (COD)
    #[must_use]
    pub fn calcium_oxalate_dihydrate() -> Self {
        Self {
            youngs_modulus: 25e9, // Slightly stiffer
            density: 2000.0,
            fracture_toughness: 0.6e6,
            surface_energy: 0.6,
            compressive_strength: 60e6,
            tensile_strength: 6e6,
            hardness: 4e9,
            acoustic_impedance: 4.2e6,
            attenuation_coefficient: 40.0,
            poissons_ratio: 0.25,
        }
    }

    /// Calcium phosphate (apatite)
    #[must_use]
    pub fn calcium_phosphate() -> Self {
        Self {
            youngs_modulus: 80e9, // Much stiffer
            density: 3100.0,
            fracture_toughness: 1.2e6, // Higher fracture toughness
            surface_energy: 1.0,
            compressive_strength: 150e6, // Very strong in compression
            tensile_strength: 15e6,
            hardness: 6e9,
            acoustic_impedance: 8.5e6,
            attenuation_coefficient: 80.0,
            poissons_ratio: 0.30,
        }
    }

    /// Uric acid stones
    #[must_use]
    pub fn uric_acid() -> Self {
        Self {
            youngs_modulus: 5e9, // Much softer
            density: 1600.0,
            fracture_toughness: 0.2e6, // Lower fracture toughness
            surface_energy: 0.3,
            compressive_strength: 20e6,
            tensile_strength: 2e6,
            hardness: 1e9,
            acoustic_impedance: 3.2e6,
            attenuation_coefficient: 30.0,
            poissons_ratio: 0.35,
        }
    }

    /// Cystine stones
    #[must_use]
    pub fn cystine() -> Self {
        Self {
            youngs_modulus: 8e9,
            density: 1500.0,
            fracture_toughness: 0.3e6,
            surface_energy: 0.4,
            compressive_strength: 25e6,
            tensile_strength: 3e6,
            hardness: 1.5e9,
            acoustic_impedance: 2.8e6,
            attenuation_coefficient: 25.0,
            poissons_ratio: 0.40,
        }
    }

    /// Validate material properties
    pub fn validate(&self) -> ValidationResult {
        let mut errors: Vec<String> = Vec::new();

        if self.youngs_modulus <= 0.0 {
            errors.push(
                ValidationError::FieldValidation {
                    field: "youngs_modulus".to_string(),
                    value: self.youngs_modulus.to_string(),
                    constraint: "Must be positive".to_string(),
                }
                .to_string(),
            );
        }

        if !(0.0..=0.5).contains(&self.poissons_ratio) {
            errors.push(
                ValidationError::FieldValidation {
                    field: "poissons_ratio".to_string(),
                    value: self.poissons_ratio.to_string(),
                    constraint: "Must be between 0 and 0.5".to_string(),
                }
                .to_string(),
            );
        }

        if self.density <= 0.0 {
            errors.push(
                ValidationError::FieldValidation {
                    field: "density".to_string(),
                    value: self.density.to_string(),
                    constraint: "Must be positive".to_string(),
                }
                .to_string(),
            );
        }

        if self.fracture_toughness <= 0.0 {
            errors.push(
                ValidationError::FieldValidation {
                    field: "fracture_toughness".to_string(),
                    value: self.fracture_toughness.to_string(),
                    constraint: "Must be positive".to_string(),
                }
                .to_string(),
            );
        }

        if errors.is_empty() {
            ValidationResult::success()
        } else {
            ValidationResult::from_errors(errors)
        }
    }
}

/// Fracture mechanics calculations
/// Fracture mechanics calculations
#[derive(Debug)]
pub struct FractureMechanics {
    /// Material properties
    material: StoneMaterial,
    /// Critical stress intensity factor (same as fracture toughness)
    k_critical: f64,
}

impl FractureMechanics {
    /// Create new fracture mechanics calculator
    #[must_use]
    pub fn new(material: StoneMaterial) -> Self {
        Self {
            k_critical: material.fracture_toughness,
            material,
        }
    }

    /// Calculate Griffith critical crack length
    ///
    /// The Griffith criterion gives the critical crack size where fracture initiates:
    /// a_critical = (K_c / (π σ))^2
    ///
    /// # Arguments
    /// * `stress` - Applied stress [Pa]
    ///
    /// # Returns
    /// Critical crack length [m]
    #[must_use]
    pub fn griffith_critical_crack_length(&self, stress: f64) -> f64 {
        if stress <= 0.0 {
            return f64::INFINITY; // No fracture possible
        }

        // Griffith criterion: a_critical = (K_c / (π σ))^2
        let a_critical = (self.k_critical / (PI * stress)).powi(2);

        // Ensure reasonable bounds (cracks smaller than atomic spacing don't make sense)
        a_critical.clamp(1e-9, 1.0) // Between 1 nm and 1 m
    }

    /// Calculate stress intensity factor for a crack
    ///
    /// For a surface crack: K_I = σ √(π a) * F
    /// For an embedded crack: K_I = σ √(π a) * F
    ///
    /// # Arguments
    /// * `stress` - Applied stress [Pa]
    /// * `crack_length` - Crack half-length [m]
    /// * `geometry_factor` - Geometric correction factor (typically 1.0-1.2)
    ///
    /// # Returns
    /// Stress intensity factor [Pa·√m]
    #[must_use]
    pub fn stress_intensity_factor(
        &self,
        stress: f64,
        crack_length: f64,
        geometry_factor: f64,
    ) -> f64 {
        stress * (PI * crack_length).sqrt() * geometry_factor
    }

    /// Check if fracture will occur
    ///
    /// Fracture occurs when K_I > K_critical
    #[must_use]
    pub fn will_fracture(&self, stress: f64, crack_length: f64, geometry_factor: f64) -> bool {
        let k_i = self.stress_intensity_factor(stress, crack_length, geometry_factor);
        k_i > self.k_critical
    }

    /// Calculate fracture energy release rate
    ///
    /// G = (K_I² / E') where E' = E / (1 - ν²) for plane strain
    #[must_use]
    pub fn energy_release_rate(&self, stress_intensity: f64) -> f64 {
        let e_prime = self.material.youngs_modulus / (1.0 - self.material.poissons_ratio.powi(2));
        stress_intensity.powi(2) / e_prime
    }

    /// Calculate dynamic crack propagation velocity
    ///
    /// Based on Freund (1990): Crack propagation in solids
    /// v_crack = (0.38 + 0.60ν) * c_elastic where ν is Poisson's ratio
    #[must_use]
    pub fn crack_velocity(&self) -> f64 {
        let c_elastic = (self.material.youngs_modulus / self.material.density).sqrt();
        let nu = self.material.poissons_ratio;
        (0.38 + 0.60 * nu) * c_elastic
    }

    /// Calculate fragment size distribution after fracture
    ///
    /// Based on Grady-Kipp fragmentation model for dynamic fracture
    /// Fragment size scales as: d ∝ (G / σ²)^{1/3}
    ///
    /// # Arguments
    /// * `strain_rate` - Strain rate during fracture [s⁻¹]
    ///
    /// # Returns
    /// Characteristic fragment diameter [m]
    #[must_use]
    pub fn fragment_size(&self, strain_rate: f64) -> f64 {
        if strain_rate <= 0.0 {
            return 1.0; // Default size
        }

        // Grady-Kipp model: d ∝ (G / σ²)^{1/3} where G is fracture energy
        // Using fracture toughness as proxy for fracture energy
        let g_fracture = self.material.fracture_toughness.powi(2) / self.material.youngs_modulus;

        // Characteristic stress (use compressive strength as upper bound)
        let sigma = self.material.compressive_strength;

        // Fragment size scales as (G / σ²)^{1/3}
        let fragment_size = (g_fracture / sigma.powi(2)).powf(1.0 / 3.0);

        // Scale by strain rate effects (higher strain rate -> smaller fragments)
        let strain_rate_factor = 1.0 / (1.0 + (strain_rate * 1e-6).ln().max(0.0));
        fragment_size * strain_rate_factor
    }
}

/// Stone fracture model combining material properties and damage mechanics
#[derive(Debug)]
pub struct StoneFractureModel {
    /// Material properties
    material: StoneMaterial,
    /// Fracture mechanics calculator
    fracture: FractureMechanics,
    /// Damage field (0 = intact, 1 = fully fractured)
    damage_field: Array3<f64>,
    /// Crack density field [m⁻¹]
    crack_density: Array3<f64>,
    /// Fragment size distribution [m]
    fragment_sizes: Vec<f64>,
}

impl StoneFractureModel {
    /// Create new stone fracture model
    #[must_use]
    pub fn new(material: StoneMaterial, grid_shape: (usize, usize, usize)) -> Self {
        let fracture = FractureMechanics::new(material.clone());
        let damage_field = Array3::zeros(grid_shape);
        let crack_density = Array3::zeros(grid_shape);

        Self {
            material,
            fracture,
            damage_field,
            crack_density,
            fragment_sizes: Vec::new(),
        }
    }

    /// Apply stress loading and calculate fracture progression
    ///
    /// # Arguments
    /// * `stress_field` - Applied stress field [Pa]
    /// * `time_step` - Time step for damage accumulation [s]
    /// * `strain_rate` - Strain rate during loading [s⁻¹]
    pub fn apply_stress_loading(
        &mut self,
        stress_field: &Array3<f64>,
        time_step: f64,
        strain_rate: f64,
    ) {
        // Calculate damage accumulation at each point
        for ((i, j, k), stress) in stress_field.indexed_iter() {
            let stress_val = *stress;

            // Calculate critical crack length for current stress
            let a_critical = self.fracture.griffith_critical_crack_length(stress_val);

            // Current crack density at this location
            let current_cracks = self.crack_density[[i, j, k]];

            // Complete fracture mechanics implementation
            // Literature: Coleman et al. (1987) - Acoustic Cavitation and Bubble Dynamics
            // Paris' Law for fatigue crack growth: da/dN = C * (ΔK)^m

            let stress_ratio = stress_val / self.material.tensile_strength;

            // Fracture initiation (Griffith criterion)
            if stress_ratio > 0.3 {
                // Threshold for initial crack formation
                // Griffith criterion: σ_critical = sqrt(2Eγ/(πa))
                // Simplified: damage initiates when stress exceeds material strength
                let initiation_probability = (stress_ratio - 0.3).clamp(0.0, 1.0);

                if rand::random::<f64>() < initiation_probability * time_step {
                    // Initiate new crack
                    self.crack_density[[i, j, k]] += 1e-6; // Small initial crack density
                }
            }

            // Fatigue crack growth (Paris' law)
            if current_cracks > 0.0 && stress_ratio > 0.1 {
                // Stress intensity factor range: ΔK = Y * σ * sqrt(π * a)
                // Y ≈ 1.12 for surface cracks (simplified)
                let stress_intensity_range =
                    1.12 * stress_val * (std::f64::consts::PI * current_cracks).sqrt();

                // Paris' law parameters for kidney stones (literature-based approximation)
                let c_paris = 1e-10; // Crack growth rate coefficient [m/cycle]
                let m_paris = 2.0; // Paris' law exponent

                // Crack growth per stress cycle: da/dN = C * (ΔK)^m
                let crack_growth_rate = c_paris * stress_intensity_range.powf(m_paris);

                // Convert to damage accumulation (normalized 0-1 scale)
                // Assume fracture when crack reaches critical size
                let critical_crack_length = a_critical;
                let damage_increment = crack_growth_rate / critical_crack_length;

                let current_damage = self.damage_field[[i, j, k]];
                let new_damage = (current_damage + damage_increment * time_step).min(1.0);
                self.damage_field[[i, j, k]] = new_damage;

                // Update crack density based on growth
                self.crack_density[[i, j, k]] += crack_growth_rate * time_step;
            }

            // Spallation damage (tensile failure from rarefaction waves)
            // Occurs when tensile stress exceeds material strength
            if stress_val < -self.material.tensile_strength * 0.5 {
                // Negative stress = tension
                let tensile_stress = -stress_val; // Convert to positive for calculations
                let spallation_damage =
                    (tensile_stress / self.material.tensile_strength).powf(1.5) * time_step;

                let current_damage = self.damage_field[[i, j, k]];
                let new_damage = (current_damage + spallation_damage).min(1.0);
                self.damage_field[[i, j, k]] = new_damage;

                // Spallation creates surface cracks
                if new_damage > current_damage {
                    self.crack_density[[i, j, k]] += spallation_damage * 1e10;
                }
            }

            // Cavitation erosion (bubble collapse damage)
            // Literature: Philipp & Lauterborn (1998) - Cavitation erosion by single laser pulses
            let cavitation_damage = self.compute_cavitation_erosion(stress_val, time_step);
            if cavitation_damage > 0.0 {
                let current_damage = self.damage_field[[i, j, k]];
                let new_damage = (current_damage + cavitation_damage).min(1.0);
                self.damage_field[[i, j, k]] = new_damage;
            }

            // Check for complete fracture (Griffith criterion)
            if self
                .fracture
                .will_fracture(stress_val, a_critical, current_cracks)
            {
                self.damage_field[[i, j, k]] = 1.0; // Complete fracture
            }
        }

        // Calculate fragment sizes for fully fractured regions
        self.calculate_fragment_sizes(strain_rate);
    }

    /// Calculate fragment sizes for fractured regions
    fn calculate_fragment_sizes(&mut self, strain_rate: f64) {
        self.fragment_sizes.clear();

        // Find fractured regions and calculate their fragment sizes
        for &damage in self.damage_field.iter() {
            if damage >= 1.0 {
                let fragment_size = self.fracture.fragment_size(strain_rate);
                self.fragment_sizes.push(fragment_size);
            }
        }
    }

    /// Compute cavitation erosion damage from bubble collapse
    /// Literature: Philipp & Lauterborn (1998) - Cavitation erosion by single laser pulses
    fn compute_cavitation_erosion(&self, stress: f64, time_step: f64) -> f64 {
        // Cavitation erosion occurs when bubbles collapse near surfaces
        // Damage is proportional to bubble collapse energy and surface proximity

        // Simplified model: erosion increases with compressive stress (bubble collapse)
        if stress > 0.0 {
            // Empirical relation: erosion rate ∝ stress^2 * time
            // Literature-based approximation for kidney stone erosion
            let erosion_rate = (stress / self.material.tensile_strength).powf(2.0) * 1e-6;
            erosion_rate * time_step
        } else {
            0.0
        }
    }

    /// Get damage field
    #[must_use]
    pub fn damage_field(&self) -> &Array3<f64> {
        &self.damage_field
    }

    /// Get crack density field
    #[must_use]
    pub fn crack_density(&self) -> &Array3<f64> {
        &self.crack_density
    }

    /// Get fragment size distribution
    #[must_use]
    pub fn fragment_sizes(&self) -> &[f64] {
        &self.fragment_sizes
    }

    /// Calculate total fractured volume fraction
    #[must_use]
    pub fn fractured_volume_fraction(&self) -> f64 {
        let total_voxels = self.damage_field.len() as f64;
        let fractured_voxels = self.damage_field.iter().filter(|&&d| d >= 1.0).count() as f64;
        fractured_voxels / total_voxels
    }

    /// Get material properties
    #[must_use]
    pub fn material(&self) -> &StoneMaterial {
        &self.material
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_griffith_critical_crack_length() {
        let material = StoneMaterial::calcium_oxalate_monohydrate();
        let fracture = FractureMechanics::new(material);

        // For typical lithotripsy stress of 100 MPa
        let stress = 100e6; // 100 MPa
        let a_critical = fracture.griffith_critical_crack_length(stress);

        // Should be reasonable crack length (micrometers to millimeters)
        assert!(a_critical > 1e-6 && a_critical < 1e-2);

        // Higher stress should give smaller critical crack length
        let high_stress = 500e6; // 500 MPa
        let a_critical_high = fracture.griffith_critical_crack_length(high_stress);
        assert!(a_critical_high < a_critical);
    }

    #[test]
    fn test_will_fracture() {
        let material = StoneMaterial::calcium_oxalate_monohydrate();
        let fracture = FractureMechanics::new(material);

        // Test with stress below tensile strength
        let low_stress = 1e6; // 1 MPa
        let crack_length = 1e-3; // 1 mm crack
        assert!(!fracture.will_fracture(low_stress, crack_length, 1.0));

        // Test with high stress and long crack
        let high_stress = 50e6; // 50 MPa
        let long_crack = 1e-2; // 1 cm crack
        assert!(fracture.will_fracture(high_stress, long_crack, 1.0));
    }

    #[test]
    fn test_material_properties() {
        let com = StoneMaterial::calcium_oxalate_monohydrate();
        let cod = StoneMaterial::calcium_oxalate_dihydrate();
        let uric = StoneMaterial::uric_acid();

        // COM should have intermediate properties
        assert!(com.youngs_modulus < cod.youngs_modulus); // COD is stiffer
        assert!(com.youngs_modulus > uric.youngs_modulus); // Uric is softer

        // All materials should validate
        assert!(com.validate().is_ok());
        assert!(cod.validate().is_ok());
        assert!(uric.validate().is_ok());
    }
}
